Debugging with GDB or LLDB
**************************

.. warning:: Some of the facilities described here are only
   available in builds from April 11, 2013 or later.
   :class: alert alert-block alert-warning

.. warning:: On Mac OS X, we recommend using lldb to debug
   rather than gdb.
   :class: alert alert-block alert-warning

Which compiler backend are you using?
=====================================

If you are using the C backend, then the information discussed here
will be useful for debugging. We use the C backend on 64 bit Linux,
64 bit FreeBSD and all Mac OS X versions.

If you're using the HARP backend (32 bit Linux or 32 bit FreeBSD), then
you'll be limited to getting stack traces.


Debugging with the C backend
============================

Debugging with the C backend is not a perfect experience but it is
improving.

Finding the generated C files
-----------------------------

The C files generated by the compiler will be found under the
``_build/build`` directory with a directory in there for each
library that was built as part of the project.

Finding the corresponding Dylan code
------------------------------------

The generated C files contain the file name and line number of the
corresponding Dylan source. However, this may be confusing in the
presence of inlined functions and macro expansions.

Understanding name mangling
---------------------------

*Fill this in, particularly with a link to the Hacker's Guide!*

Breaking on main
----------------

Unfortunately, you can't simply set a breakpoint on ``main``. This is because
the generated code runs from shared library constructor functions so the
entire Dylan application runs and exits prior to ``main`` being invoked.

A reasonable alternative is to determine the C name of your entry point
function and set a breakpoint on that instead.

Inspecting Dylan objects
------------------------

The C runtime contains a number of helper functions specifically for
improving the debugging process. These can be invoked from gdb or lldb
and will assist you in analyzing values.

.. c:function:: D dylan_object_class(D* instance)

   Returns the class instance for the given instance object.

.. c:function:: bool dylan_boolean_p (D instance)

   Tests whether instance is a ``<boolean>``.

.. c:function:: bool dylan_true_p (D instance)

   Tests whether instance is ``#t``.

.. c:function:: bool dylan_float_p (D instance)

   Tests whether instance is a ``<float>``.

.. c:function:: bool dylan_single_float_p (D instance)

   Tests whether instance is a ``<single-float>``.

.. c:function:: float dylan_single_float_data (D instance)

   Returns the ``float`` data stored in the instance.

.. c:function:: bool dylan_double_float_p (D instance)

   Tests whether instance is a ``<double-float>``.

.. c:function:: double dylan_double_float_data (D instance)

   Returns the ``double`` data stored in the instance.

.. c:function:: bool dylan_symbol_p (D instance)

   Tests whether instance is a ``<symbol>``.

.. c:function:: D dylan_symbol_name (D instance)

   Returns the string form of the given symbol.

.. c:function:: bool dylan_pair_p (D instance)

   Tests whether instance is a ``<pair>``.

.. c:function:: bool dylan_empty_list_p (D instance)

   Tests whether instance is an empty list.

.. c:function:: D dylan_head (D instance)

   Returns the head of the given ``<pair>`` instance.

.. c:function:: D dylan_tail (D instance)

   Returns the tail of the given ``<pair>`` instance.

.. c:function:: bool dylan_vector_p (D instance)

   Tests whether instance is a ``<vector>``.

.. c:function:: bool dylan_string_p (D instance)

   Tests whether instance is a ``<string>``.

.. c:function:: char* dylan_string_data (D instance)

   Returns the C string data stored in the given instance.

.. c:function:: bool dylan_simple_condition_p (D instance)

   Tests whether instance is a ``<simple-condition>``.

.. c:function:: D dylan_simple_condition_format_string (D instance)

   Returns the format string stored in the given ``<simple-condition>``.

.. c:function:: D dylan_simple_condition_format_args (D instance)

   Returns the format string arguments stored in the given
   ``<simple-condition>``.

.. c:function:: bool dylan_class_p (D instance)

   Tests whether instance is a ``<class>``.

.. c:function:: D dylan_class_debug_name (D instance)

   Returns the ``<string>`` object containing the class's name.

.. c:function:: bool dylan_function_p (D instance)

   Tests whether instance is a ``<function>``.

.. c:function:: D dylan_function_debug_name (D instance)

   Returns the ``<string>`` object containing the function's name.
   Note that we do not store the name for all function objects.

.. c:function:: void dylan_print_object (D object)

   Print some information about the given object to ``stdout``.

Debugging with the HARP backend
===============================

As mentioned previously, this is largely limited to getting stack
traces.  If you try to run a Dylan application built with the
HARP backend under the debugger, you may need to adjust your
debugger's signal handling.

*Add more notes about this later.*
